package glgui;

import ogl.GLM;
import goodies.Builder;
using goodies.Maybe;
import goodies.Lazy;
import goodies.Func;
import glgui.Gui;

enum MouseButton {
    MouseLeft;
    MouseMiddle;
    MouseRight;
}

/**
 * Virtual GUI element for mouse events.
 */
class Mouse implements Element<Mouse> {

    // Element
    @:builder var active = true;
    @:builder var fit:Vec4 = [0.0,0.0,0.0,0.0];
    @:builder var occluder = false;

    // Mouse
    /** Button disabled, still receive enter/exit, but not press/release **/
    @:builder var disabled = false;
    /** Button is a toggle mouse area **/
    @:builder var toggle   = false;

    /**
      * Function defining what it is to be in the mouse areas area.
      * If null, then the mouse areas 'fit' rectangle is used
      */
    @:builder var interior:Maybe<Vec2->Bool> = null;

    /** Handler for mouse-enter event */
    @:builder var enter  :Maybe<Void->Void> = null;
    /** Handler for mouse-exit event */
    @:builder var exit   :Maybe<Void->Void> = null;
    /** Handler for mouse-press event, with mouse area pressed */
    @:builder var press  :Maybe<Maybe<Vec2>->MouseButton->Void> = null;
    /** Handler for mouse-release event, with mouse area released */
    @:builder var release:Maybe<Maybe<Vec2>->MouseButton->Bool->Void> = null;
    /** Handler for mouse-over event, wtith mouse position */
    @:builder var over:Maybe<Maybe<Vec2>->Void> = null;
    /** Handler for mouse-scroll event */
    @:builder var scroll :Maybe<Float->Void>  = null;


    @:builder var focus:Maybe<Void->Void> = null;

    /** Handler for key event (in sight) */
    /** Handler for character event (in sight) */
    @:builder var key:Maybe<Array<{key:Int,state:KeyState}>->Void> = null;
    // Corresponds to any ascii code
    // generated by the keyboard like a/A 1/! etc
    // taking into account shift/ctrl/alt/numlock/capslock etc
    // including space and tab character.
    //
    // Things like backspace/delete/home/end/left/right etc
    // should be used with Key Event matching against KSPress
    // and KSDelayedHold for character type processing.
    @:builder var character:Maybe<Array<Int>->Void> = null;

    /** If mouse is currently over mouse area */
    public var isOver         (default,null) = false;
    /** If mouse left button area is currently pressed on mouse area */
    public var isPressedLeft  (default,null) = false;
    /** If mouse right button area is currently pressed on mouse area */
    public var isPressedRight (default,null) = false;
    /** If mouse middle button area is currently pressed on mouse area */
    public var isPressedMiddle(default,null) = false;

    public function new() {}

    // Element
    public function destroy() {}
    // Element
    public function internal(x:Vec2) {
        var int = getInterior();
        return int.run(
            Func.call1.bind(_,x),
            function () {
                var fit = getFit();
                var dx = x.x - fit.x;
                var dy = x.y - fit.y;
                return dx >= 0 && dx <= fit.z &&
                       dy >= 0 && dy <= fit.w;
            }
        );
    }
    // Element
    public function bounds():Maybe<Vec4> return null;
    // Element
    public function commit() {
        return this;
    }

    // Called by Gui when mouse is definitely inside mouse area
    // (and not occluded)
    @:allow(glgui)
    function inside(gui:Gui) {
        if (!isOver) {
            isOver = true;
            getEnter().call();
        }
        getOver().call1(cast gui.getMousePos());
        if (!isPressedLeft && gui.mouseWasPressedLeft) {
            isPressedLeft = true;
            getPress().call2(cast gui.getMousePos(), MouseLeft);
            gui.sightLeft.push(this);
        }
        if (!isPressedRight && gui.mouseWasPressedRight) {
            isPressedRight = true;
            getPress().call2(cast gui.getMousePos(), MouseRight);
            gui.sightRight.push(this);
        }
        if (!isPressedMiddle && gui.mouseWasPressedMiddle) {
            isPressedMiddle = true;
            getPress().call2(cast gui.getMousePos(), MouseMiddle);
            gui.sightMiddle.push(this);
        }

        if (gui.getMouseScroll() != 0)
            getScroll().call1(gui.getMouseScroll());
    }

    // Called by Gui when mouse is definitely outside mouse area
    // or occluded.
    @:allow(glgui)
    function outside(gui:Gui) {
        if (isOver) {
            isOver = false;
            getExit().call();
        }
    }

    // Called by Gui when left key is released on pressed mouse area
    // etc for other buttons.
    @:allow(glgui)
    function releasedLeft(pos:Maybe<Vec2>) {
        isPressedLeft = false;
        getRelease().call3(cast pos, MouseLeft, isOver);
    }
    @:allow(glgui)
    function releasedRight(pos:Maybe<Vec2>) {
        isPressedRight = false;
        getRelease().call3(cast pos, MouseRight, isOver);
    }
    @:allow(glgui)
    function releasedMiddle(pos:Maybe<Vec2>) {
        isPressedMiddle = false;
        getRelease().call3(cast pos, MouseMiddle, isOver);
    }

    // Element
    public function render(gui:Gui, mousePos:Maybe<Vec2>, _, _) {
        if (mousePos.runOr(internal, false)) gui.registerMouse(this);
        else outside(gui);
    }
}
